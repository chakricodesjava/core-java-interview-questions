# Core Java Interview Questions - Part 1
## (For Experienced Developers)
## Q1. Difference between JDK, JRE, and JVM
Core Answer:
- JVM: The abstract machine that executes bytecode.
- JRE: JVM + standard libraries (runtime only).
- JDK: JRE + development tools (compiler, debugger, jlink, jdeps).

Deep Explanation:
- JVM is a specification (e.g., HotSpot is one implementation).
- JRE historically was a separate download; now modern JDK distributions bundle all.
- With Java modules (Java 9+), you can create custom runtimes (jlink).
- Interviewers expect you to mention portability and the role of bytecode in WORA (Write Once Run Anywhere).

---

## Q2. Is Java 100% Object-Oriented?
Quick Answer: No‚Äîprimitives are not objects.

Depth:
- Primitives (int, boolean, double‚Ä¶) don‚Äôt have methods and aren‚Äôt instances of classes.
- Wrapper types (Integer, Boolean, etc.) bridge the gap.
- Autoboxing makes it look objecty but has performance and semantic differences.
 

---

## Q3. What is Bytecode?
Answer: Intermediate instruction set (.class) executed by the JVM.

Depth:
- Generated by javac (or other compilers like Kotlin, Scala).
- JIT compiles hot sections to native code.
- Enables optimization techniques (inlining, escape analysis).


---

## Q4. Explain public static void main(String[] args)
Breakdown:
- public: Required so JVM can call it via reflection.
- static: No object needed.
- void: No return value expected; exit codes via System.exit().
- String[] args: CLI arguments.
 
---

## Q5. == vs equals()
Core:
- == : reference comparison for objects (or value compare for primitives).
- equals(): logical equality (may be overridden).
 
---

## Q6. Autoboxing / Unboxing
Definition: Automatic conversion between primitive and wrapper.

Performance Impact:
- Boxing creates objects‚Äîcan hurt GC in loops.
- Null unboxing throws NullPointerException.
 

---

## Q7. Default Values of Instance Variables
Defaults (instance members):
- int: 0
- long: 0L
- boolean: false
- char: '\u0000'
- Object refs: null

Local variables: MUST be explicitly initialized.

---

## Q8. Pass-by-Value or Reference?
Java is strictly pass-by-value. For object parameters, the value passed is the reference (pointer) copy.
But here‚Äôs the trick:

When you pass a primitive, the actual value is copied.

When you pass an object, the value of the reference (memory address) is copied ‚Äî not the object itself.
So both variables point to the same object, but the reference itself is a copy.

That‚Äôs why people sometimes get confused and think Java is pass-by-reference.

üìå Example 1: Primitives (Pass-by-Value)
public class PassByValue {
public static void changeValue(int x) {
x = 50;
}

    public static void main(String[] args) {
        int a = 10;
        changeValue(a);
        System.out.println(a); // 10 (not changed)
    }
}

Example:
```java
void mutate(StringBuilder sb){ sb.append("X"); }
void reassign(StringBuilder sb){ sb = new StringBuilder("New"); }

StringBuilder a = new StringBuilder("A");
mutate(a);       // a -> "AX"
reassign(a);     // a still "AX"
```

Pitfall: Saying ‚ÄúJava is pass-by-reference.‚Äù  

---

## Q9. Primitive vs Wrapper Types
Comparison:
- Performance: primitives faster.
- Nullability: wrappers can be null.
- Collections: need wrappers.
- Identity semantics: wrappers cached for some values.

---

## Q10. What is a Package?
Purpose: Namespace control, prevents naming conflicts, access control (package-private visibility).

---

## Q11. Four Pillars of OOP
List: Encapsulation, Inheritance, Polymorphism, Abstraction.

Short Clarifications:
- Encapsulation: Hide data behind methods.
- Inheritance: Reuse via extends (use sparingly).
- Polymorphism: Runtime dispatch based on actual type.
- Abstraction: Focus on essential behavior (interfaces/abstract classes).
 
---

## Q12. Abstraction vs Encapsulation
Abstraction: Expose what something does (interfaces).  
Encapsulation: Hiding internal state & representation (private fields).
 
---

## Q13. Method Overloading vs Overriding
Overloading: Same name, different parameter list (compile-time resolution).  
Overriding: Same signature in subclass, runtime dispatch.
 
---

## Q14. Can Static Methods Be Overridden?
Answer: No. They are hidden (shadowed). Binding is compile-time.
 

---

## Q15. Can Constructors Be Overridden?
Answer: No. They are not inherited. They can be overloaded.
 

---

## Q16. this vs super
this: Refers to current instance.  
super: Refers to immediate parent implementation / constructor.
 

---

## Q17. Order of Initialization
Order:
1. Static fields & static blocks (parent ‚Üí child).
2. Instance fields & instance initializer blocks (parent ‚Üí child).
3. Constructors (parent ‚Üí child).
 
Pitfall: Relying on uninitialized fields during chain.  
Quiz: ‚ÄúWhen does child static block run?‚Äù (After parent static.)

---

## Q18. Composition vs Inheritance
Composition: ‚ÄúHas-a‚Äù, more flexible.  
Inheritance: ‚ÄúIs-a‚Äù, tight coupling.
 
---

## Q19. Uses of final
- final variable: reference cannot be reassigned.
- final field + proper construction = safe publication for immutable objects.
- final method: cannot be overridden.
- final class: cannot be subclassed (e.g., String).
 
---

## Q20. Designing an Immutable Class
Rules:
- Declare class final (optional but recommended).
- All fields private & final.
- No setters.
- Defensive copies for mutable inputs & outputs.
- Ensure ‚Äòthis‚Äô not leaked during construction.
  
---
 
