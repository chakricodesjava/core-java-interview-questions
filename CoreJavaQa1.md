# Core Java Interview Series ‚Äì Section 1 (Q1‚ÄìQ20)
In-Depth Script + Examples + Visual Prompts  
Use this as the master script for your FIRST long-form YouTube video (can be split into 2 parts: Q1‚ÄìQ10 and Q11‚ÄìQ20).  
Style Guide:
- Hook (first 10s)
- Clear explanation
- Real-world analogy
- Code example (runnable + edge-case)
- Pitfalls & Interview Traps
- Mini-Quiz / Pause prompt
- Transition line

---

## VIDEO OPENING (Suggested)
Hook (on camera):  
‚ÄúMost Java interviews start with deceptively simple questions like ‚ÄòWhat‚Äôs the difference between JDK, JRE, and JVM?‚Äô‚Äîbut how you answer reveals how deep your understanding really is. Today, we‚Äôll go through 20 foundational Java questions with the kind of depth that impresses senior interviewers.‚Äù

CTA:  
‚ÄúDownload the notes from the repo and comment which section you want next‚ÄîJVM internals or Collections.‚Äù

---

## Q1. Difference between JDK, JRE, and JVM
Core Answer:
- JVM: The abstract machine that executes bytecode.
- JRE: JVM + standard libraries (runtime only).
- JDK: JRE + development tools (compiler, debugger, jlink, jdeps).

Deep Explanation:
- JVM is a specification (e.g., HotSpot is one implementation).
- JRE historically was a separate download; now modern JDK distributions bundle all.
- With Java modules (Java 9+), you can create custom runtimes (jlink).
- Interviewers expect you to mention portability and the role of bytecode in WORA (Write Once Run Anywhere).

Real-World Analogy:  
Think of JVM as the engine, JRE as the fully assembled car (engine + essential parts), and JDK as the factory tools used to design and build cars.

Code Demo (Show path differences):
```bash
# Show installed components
java -version
javac -version
jar --help
jdeps --version
```

Pitfall: Saying ‚ÄúJDK contains JRE‚Äù without acknowledging current modularization trends.  
Mini Quiz: ‚ÄúIf I want to analyze dependencies of my JAR, which part do I need?‚Äù (Answer: JDK, for jdeps).

Visual Prompt: Concentric rings: JDK (outer) ‚Üí JRE ‚Üí JVM ‚Üí Bytecode.

Transition: ‚ÄúNow that we know the toolchain, let‚Äôs talk about whether Java is truly ‚Äòobject-oriented.‚Äô‚Äù

---

## Q2. Is Java 100% Object-Oriented?
Quick Answer: No‚Äîprimitives are not objects.

Depth:
- Primitives (int, boolean, double‚Ä¶) don‚Äôt have methods and aren‚Äôt instances of classes.
- Wrapper types (Integer, Boolean, etc.) bridge the gap.
- Autoboxing makes it look objecty but has performance and semantic differences.

Code Example ‚Äì Subtle Autobox Behavior:
```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b); // true (cached range -128..127)

Integer c = 128;
Integer d = 128;
System.out.println(c == d); // false (outside cache)

int x = 128;
int y = 128;
System.out.println(x == y); // true (primitive compare)
```

Pitfall: Claiming ‚ÄúEverything in Java is an object.‚Äù  
Interview Flex: Mention value types (Project Valhalla) are coming to reduce primitive/object gap.

Visual: Two columns: Primitive vs Wrapper (Nullability, Memory, Caching, Performance).  
Mini Quiz: ‚ÄúWhat happens if you unbox a null Integer?‚Äù (NullPointerException).

---

## Q3. What is Bytecode?
Answer: Intermediate instruction set (.class) executed by the JVM.

Depth:
- Generated by javac (or other compilers like Kotlin, Scala).
- JIT compiles hot sections to native code.
- Enables optimization techniques (inlining, escape analysis).

Demo (Disassemble):
```java
public class Hello {
  public static void main(String[] args) {
    String msg = "Hi";
    System.out.println(msg);
  }
}
```
```bash
javac Hello.java
javap -c Hello
```

Pitfall: Saying ‚ÄúBytecode is platform independent‚Äù without acknowledging the JVM must exist for that platform.  
Visual: Source -> javac -> bytecode -> JIT -> CPU.  
Quiz: ‚ÄúWhich tool shows bytecode?‚Äù (javap)

---

## Q4. Explain public static void main(String[] args)
Breakdown:
- public: Required so JVM can call it via reflection.
- static: No object needed.
- void: No return value expected; exit codes via System.exit().
- String[] args: CLI arguments.

Extended Points:
- Signature variants accepted: `public static void main(String... args)`
- Order or modifiers wrong? JVM won‚Äôt find it.
- You can overload main, but JVM only invokes the canonical one.

Example:
```java
public class Entry {
  public static void main(String[] args) {
    System.out.println("Args length = " + args.length);
  }
  public static void main(int x) { System.out.println("Overloaded main"); }
}
```

Pitfall: Forgetting ‚Äústatic‚Äù or having private scope.  
Quiz: ‚ÄúCan main be non-static if we create an object first?‚Äù (No, JVM cannot call it automatically.)

---

## Q5. == vs equals()
Core:
- == : reference comparison for objects (or value compare for primitives).
- equals(): logical equality (may be overridden).

Example:
```java
String s1 = new String("java");
String s2 = new String("java");
System.out.println(s1 == s2);       // false
System.out.println(s1.equals(s2));  // true
```

Deep Edge:
- For enums: == is safe (singletons).
- For wrappers: == may mislead due to caching range.

Bad Example:
```java
Integer a = 1000, b = 1000;
System.out.println(a == b); // false
```

Pitfall: Not overriding hashCode when overriding equals (leads to broken HashMap behavior).  
Quiz: ‚ÄúWhy must equals + hashCode be consistent?‚Äù Answer: Hash-based collections rely on it.

---

## Q6. Autoboxing / Unboxing
Definition: Automatic conversion between primitive and wrapper.

Performance Impact:
- Boxing creates objects‚Äîcan hurt GC in loops.
- Null unboxing throws NullPointerException.

Code:
```java
long start = System.nanoTime();
Long sum = 0L;
for (long i = 0; i < 10_000_000L; i++) {
  sum += i; // sum is Long ‚Üí boxing each iteration
}
long end = System.nanoTime();
System.out.println("Time: " + (end - start));
```
Optimize:
```java
long sum2 = 0;
for (long i = 0; i < 10_000_000L; i++) sum2 += i;
```

Pitfall: Accidental use of wrapper in hot paths.  
Quiz: ‚ÄúWhat exception from `Integer n = null; int x = n;`?‚Äù (NullPointerException)

---

## Q7. Default Values of Instance Variables
Defaults (instance members):
- int: 0
- long: 0L
- boolean: false
- char: '\u0000'
- Object refs: null

Local variables: MUST be explicitly initialized.

Example:
```java
public class Defaults {
  int x; boolean flag; String name;
  void test(){
    int local;
    // System.out.println(local); // compile error
    System.out.println(x + " " + flag + " " + name);
  }
}
```

Pitfall: Assuming local variables get defaults.  
Quiz: ‚ÄúWhat prints for uninitialized char?‚Äù Looks blank (null character).

---

## Q8. Pass-by-Value or Reference?
Java is strictly pass-by-value. For object parameters, the value passed is the reference (pointer) copy.
But here‚Äôs the trick:

When you pass a primitive, the actual value is copied.

When you pass an object, the value of the reference (memory address) is copied ‚Äî not the object itself.
So both variables point to the same object, but the reference itself is a copy.

That‚Äôs why people sometimes get confused and think Java is pass-by-reference.

üìå Example 1: Primitives (Pass-by-Value)
public class PassByValue {
public static void changeValue(int x) {
x = 50;
}

    public static void main(String[] args) {
        int a = 10;
        changeValue(a);
        System.out.println(a); // 10 (not changed)
    }
}

Example:
```java
void mutate(StringBuilder sb){ sb.append("X"); }
void reassign(StringBuilder sb){ sb = new StringBuilder("New"); }

StringBuilder a = new StringBuilder("A");
mutate(a);       // a -> "AX"
reassign(a);     // a still "AX"
```

Pitfall: Saying ‚ÄúJava is pass-by-reference.‚Äù  
Analogy: You photocopy an address; changes at the address are visible, but changing the paper‚Äôs content (new address) won‚Äôt update original.  
Quiz: ‚ÄúCan a method replace caller‚Äôs object?‚Äù (Not unless a wrapper container is mutated.)

---

## Q9. Primitive vs Wrapper Types
Comparison:
- Performance: primitives faster.
- Nullability: wrappers can be null.
- Collections: need wrappers.
- Identity semantics: wrappers cached for some values.

Example Cache Demo:
```java
Integer a = 127, b = 127;
Integer c = 128, d = 128;
System.out.println(a == b); // true
System.out.println(c == d); // false
```

Pitfall: Storing large numbers of boxed values in tight loops.  
Quiz: ‚ÄúWhy no primitives in generics?‚Äù (Type erasure design.)

---

## Q10. What is a Package?
Purpose: Namespace control, prevents naming conflicts, access control (package-private visibility).

Example:
```java
package com.example.util;
public class MathUtil {}
```

Access Modifier Impact:
- No modifier (default) means package-private.
- Use consistent domain-based naming (reverse domain carefully).

Pitfall: Cyclic package dependencies (architectural smell).  
Quiz: ‚ÄúCan two packages have same class name?‚Äù Yes‚Äîfully qualified name disambiguates.

---

## Q11. Four Pillars of OOP
List: Encapsulation, Inheritance, Polymorphism, Abstraction.

Short Clarifications:
- Encapsulation: Hide data behind methods.
- Inheritance: Reuse via extends (use sparingly).
- Polymorphism: Runtime dispatch based on actual type.
- Abstraction: Focus on essential behavior (interfaces/abstract classes).

Example (Polymorphism):
```java
interface Notifier { void send(String msg); }
class EmailNotifier implements Notifier { public void send(String msg){ System.out.println("Email: " + msg); } }
class SmsNotifier implements Notifier { public void send(String msg){ System.out.println("SMS: " + msg); } }

Notifier n = new SmsNotifier();
n.send("Hi");
```

Pitfall: Overusing inheritance where composition fits.  
Quiz: ‚ÄúWhere does dynamic dispatch occur?‚Äù (At runtime via vtable.)

---

## Q12. Abstraction vs Encapsulation
Abstraction: Expose what something does (interfaces).  
Encapsulation: Hiding internal state & representation (private fields).

Example:
```java
interface Storage { void put(String key, String val); String get(String key); }
class InMemoryStorage implements Storage {
  private final Map<String,String> map = new HashMap<>();
  public void put(String k,String v){ map.put(k,v); }
  public String get(String k){ return map.get(k); }
}
```

Pitfall: Using public fields (breaks encapsulation).  
Quiz: ‚ÄúIs abstraction possible without encapsulation?‚Äù (Yes, but they complement each other.)

---

## Q13. Method Overloading vs Overriding
Overloading: Same name, different parameter list (compile-time resolution).  
Overriding: Same signature in subclass, runtime dispatch.

Example:
```java
class Calc {
  int add(int a,int b){ return a+b; }
  double add(double a,double b){ return a+b; } // overload
}
class AdvCalc extends Calc {
  @Override
  int add(int a,int b){ return a+b+1; } // override
}
```

Pitfall: Changing only return type is NOT overloading.  
Quiz: ‚ÄúIs overriding based on parameter types?‚Äù (No‚Äîsignature must match.)

---

## Q14. Can Static Methods Be Overridden?
Answer: No. They are hidden (shadowed). Binding is compile-time.

Example:
```java
class A { static void hi(){ System.out.println("A"); } }
class B extends A { static void hi(){ System.out.println("B"); } }
A a = new B();
a.hi(); // prints A
```

Pitfall: Expecting polymorphic behavior for static methods.  
Quiz: ‚ÄúWhat prints?‚Äù (A)

---

## Q15. Can Constructors Be Overridden?
Answer: No. They are not inherited. They can be overloaded.

Example:
```java
class Person {
  Person(){ this("Unknown"); }
  Person(String name){ System.out.println(name); }
}
```

Pitfall: Thinking constructor names behave like methods.  
Quiz: ‚ÄúDoes subclass inherit parent constructors?‚Äù (No.)

---

## Q16. this vs super
this: Refers to current instance.  
super: Refers to immediate parent implementation / constructor.

Example:
```java
class Parent { Parent(){ System.out.println("Parent ctor"); } void greet(){ System.out.println("Parent greet"); } }
class Child extends Parent {
  Child(){ super(); System.out.println("Child ctor"); }
  void greet(){ super.greet(); System.out.println("Child greet"); }
}
```

Pitfall: Calling overridable methods inside constructors (can see partially constructed object).  
Quiz: ‚ÄúWhy avoid calling a non-final method in ctor?‚Äù (Subclass may see inconsistent state.)

---

## Q17. Order of Initialization
Order:
1. Static fields & static blocks (parent ‚Üí child).
2. Instance fields & instance initializer blocks (parent ‚Üí child).
3. Constructors (parent ‚Üí child).

Example:
```java
class A {
  static { System.out.println("A static"); }
  { System.out.println("A init"); }
  A(){ System.out.println("A ctor"); }
}

class B extends A {
  static { System.out.println("B static"); }
  { System.out.println("B init"); }
  B(){ System.out.println("B ctor"); }
}

public class Test {
  public static void main(String[] args) {
    new B();
  }
}
```
Output:
```
A static
B static
A init
A ctor
B init
B ctor
```

Pitfall: Relying on uninitialized fields during chain.  
Quiz: ‚ÄúWhen does child static block run?‚Äù (After parent static.)

---

## Q18. Composition vs Inheritance
Composition: ‚ÄúHas-a‚Äù, more flexible.  
Inheritance: ‚ÄúIs-a‚Äù, tight coupling.

Poor Inheritance Example:
```java
class Stack extends Vector {} // discouraged (exposes too much)
```

Good Composition:
```java
class Stack<E> {
  private final Deque<E> deque = new ArrayDeque<>();
  void push(E e){ deque.push(e); }
  E pop(){ return deque.pop(); }
}
```

Pitfall: Subclassing for code reuse leads to fragile base class problems.  
Interview Tip: Cite ‚ÄúEffective Java‚Äù (Item: Favor composition over inheritance).  
Quiz: ‚ÄúWhich is preferable for adding logging to a service?‚Äù (Composition via decorator.)

---

## Q19. Uses of final
- final variable: reference cannot be reassigned.
- final field + proper construction = safe publication for immutable objects.
- final method: cannot be overridden.
- final class: cannot be subclassed (e.g., String).

Example:
```java
final class Token {}
```

Pitfall: final reference ‚â† immutable object (internal state may mutate).  
Quiz: ‚ÄúDoes final guarantee thread-safe object?‚Äù (No‚Äîonly forbids reassignment.)

---

## Q20. Designing an Immutable Class
Rules:
- Declare class final (optional but recommended).
- All fields private & final.
- No setters.
- Defensive copies for mutable inputs & outputs.
- Ensure ‚Äòthis‚Äô not leaked during construction.

Example (with defensive copy):
```java
public final class UserProfile {
  private final String username;
  private final List<String> roles;

  public UserProfile(String username, List<String> roles) {
    this.username = username;
    this.roles = List.copyOf(roles); // defensive copy (Java 10+)
  }

  public String username(){ return username; }
  public List<String> roles(){ return roles; } // safe (unmodifiable)
}
```

Mutable Leak Example (Wrong):
```java
public List<String> roles(){ return roles; } // if roles were mutable
```

Pitfall: Exposing internal Date, List, arrays.  
Quiz: ‚ÄúWhy copy mutable collections?‚Äù (Prevent external modification.)

---

## MINI RECAP BLOCK (Optional On-Screen Slide)
Covered:
1‚Äì3: Platform & execution
4‚Äì6: Method & equality basics
7‚Äì10: Initialization & packaging
11‚Äì15: OOP pillars & dispatch
16‚Äì20: Construction order, design patterns, immutability

---

## SAMPLE SHORTS EXTRACT TEMPLATE
(For Q5 example)
Hook: ‚ÄúWhy does ‚Äò==‚Äô sometimes fail in Java strings?‚Äù  
Explain: ‚ÄúBecause ‚Äò==‚Äô checks references. Use equals() for content‚Ä¶‚Äù  
Show Code ‚Üí Provide wrapper cache twist.

---

## PRACTICE QUIZ (End of Episode)
1. Why are wrapper == comparisons unreliable sometimes?
2. What happens if you override equals but not hashCode?
3. Can static blocks access instance fields?
4. What problem does defensive copying solve?
5. Is Java pass-by-reference ever? (Answer all at end or next video.)

Answer Slide:
1. Wrapper caching & different objects.
2. Breaks HashMap contract ‚Üí lost lookups.
3. No‚Äîstatic context only has static members.
4. Prevents external mutation of internal state.
5. No‚Äîalways pass-by-value (reference value copied).

---

## RECOMMENDED VIDEO SPLIT
Part 1 (Q1‚ÄìQ10): ‚ÄúFoundations & Execution Model‚Äù  
Part 2 (Q11‚ÄìQ20): ‚ÄúObject Model & Immutability Mastery‚Äù

---

## CALL TO ACTION (End)
‚ÄúIf this helped, star the notes repo, and drop ‚ÄòPart 2‚Äô in the comments. Next: Garbage Collection or Collections‚Äîyour choice.‚Äù

---

## RAW OUTLINE (For Teleprompter)
- Hook
- JDK/JRE/JVM deep analogy
- Bytecode & JVM optimization
- main() signature nuance
- Equality (== vs equals)
- Boxing performance caution
- Initialization rules
- OOP pillars clarified
- Overloading vs overriding traps
- Immutability design fundamentals
- Recap + Quiz + CTA

---

Let me know if you want:
- Slide deck skeleton (PowerPoint / Google Slides outline)
- A printable PDF condensed cheat sheet
- Flashcards for spaced repetition (Q1‚ÄìQ20)
- A script variation in conversational tone

Just ask: ‚ÄúGenerate slides for Q1‚ÄìQ10‚Äù or ‚ÄúCreate flashcards for Section 1.‚Äù
