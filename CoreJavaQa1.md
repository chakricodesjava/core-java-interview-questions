# Core Java Interview Series â€“ Section 1 (Q1â€“Q20)
In-Depth Script + Examples + Visual Prompts  
Use this as the master script for your FIRST long-form YouTube video (can be split into 2 parts: Q1â€“Q10 and Q11â€“Q20).  
Style Guide:
- Hook (first 10s)
- Clear explanation
- Real-world analogy
- Code example (runnable + edge-case)
- Pitfalls & Interview Traps
- Mini-Quiz / Pause prompt
- Transition line

---

## VIDEO OPENING (Suggested)
Hook (on camera):  
â€œMost Java interviews start with deceptively simple questions like â€˜Whatâ€™s the difference between JDK, JRE, and JVM?â€™â€”but how you answer reveals how deep your understanding really is. Today, weâ€™ll go through 20 foundational Java questions with the kind of depth that impresses senior interviewers.â€

CTA:  
â€œDownload the notes from the repo and comment which section you want nextâ€”JVM internals or Collections.â€

---

## Q1. Difference between JDK, JRE, and JVM
Core Answer:
- JVM: The abstract machine that executes bytecode.
- JRE: JVM + standard libraries (runtime only).
- JDK: JRE + development tools (compiler, debugger, jlink, jdeps).

Deep Explanation:
- JVM is a specification (e.g., HotSpot is one implementation).
- JRE historically was a separate download; now modern JDK distributions bundle all.
- With Java modules (Java 9+), you can create custom runtimes (jlink).
- Interviewers expect you to mention portability and the role of bytecode in WORA (Write Once Run Anywhere).

Real-World Analogy:  
Think of JVM as the engine, JRE as the fully assembled car (engine + essential parts), and JDK as the factory tools used to design and build cars.

Code Demo (Show path differences):
```bash
# Show installed components
java -version
javac -version
jar --help
jdeps --version
```

Pitfall: Saying â€œJDK contains JREâ€ without acknowledging current modularization trends.  
Mini Quiz: â€œIf I want to analyze dependencies of my JAR, which part do I need?â€ (Answer: JDK, for jdeps).

Visual Prompt: Concentric rings: JDK (outer) â†’ JRE â†’ JVM â†’ Bytecode.

Transition: â€œNow that we know the toolchain, letâ€™s talk about whether Java is truly â€˜object-oriented.â€™â€

---

## Q2. Is Java 100% Object-Oriented?
Quick Answer: Noâ€”primitives are not objects.

Depth:
- Primitives (int, boolean, doubleâ€¦) donâ€™t have methods and arenâ€™t instances of classes.
- Wrapper types (Integer, Boolean, etc.) bridge the gap.
- Autoboxing makes it look objecty but has performance and semantic differences.

Code Example â€“ Subtle Autobox Behavior:
```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b); // true (cached range -128..127)

Integer c = 128;
Integer d = 128;
System.out.println(c == d); // false (outside cache)

int x = 128;
int y = 128;
System.out.println(x == y); // true (primitive compare)
```

Pitfall: Claiming â€œEverything in Java is an object.â€  
Interview Flex: Mention value types (Project Valhalla) are coming to reduce primitive/object gap.

Visual: Two columns: Primitive vs Wrapper (Nullability, Memory, Caching, Performance).  
Mini Quiz: â€œWhat happens if you unbox a null Integer?â€ (NullPointerException).

---

## Q3. What is Bytecode?
Answer: Intermediate instruction set (.class) executed by the JVM.

Depth:
- Generated by javac (or other compilers like Kotlin, Scala).
- JIT compiles hot sections to native code.
- Enables optimization techniques (inlining, escape analysis).

Demo (Disassemble):
```java
public class Hello {
  public static void main(String[] args) {
    String msg = "Hi";
    System.out.println(msg);
  }
}
```
```bash
javac Hello.java
javap -c Hello
```

Pitfall: Saying â€œBytecode is platform independentâ€ without acknowledging the JVM must exist for that platform.  
Visual: Source -> javac -> bytecode -> JIT -> CPU.  
Quiz: â€œWhich tool shows bytecode?â€ (javap)

---

## Q4. Explain public static void main(String[] args)
Breakdown:
- public: Required so JVM can call it via reflection.
- static: No object needed.
- void: No return value expected; exit codes via System.exit().
- String[] args: CLI arguments.

Extended Points:
- Signature variants accepted: `public static void main(String... args)`
- Order or modifiers wrong? JVM wonâ€™t find it.
- You can overload main, but JVM only invokes the canonical one.

Example:
```java
public class Entry {
  public static void main(String[] args) {
    System.out.println("Args length = " + args.length);
  }
  public static void main(int x) { System.out.println("Overloaded main"); }
}
```

Pitfall: Forgetting â€œstaticâ€ or having private scope.  
Quiz: â€œCan main be non-static if we create an object first?â€ (No, JVM cannot call it automatically.)

---

## Q5. == vs equals()
Core:
- == : reference comparison for objects (or value compare for primitives).
- equals(): logical equality (may be overridden).

Example:
```java
String s1 = new String("java");
String s2 = new String("java");
System.out.println(s1 == s2);       // false
System.out.println(s1.equals(s2));  // true
```

Deep Edge:
- For enums: == is safe (singletons).
- For wrappers: == may mislead due to caching range.

Bad Example:
```java
Integer a = 1000, b = 1000;
System.out.println(a == b); // false
```

Pitfall: Not overriding hashCode when overriding equals (leads to broken HashMap behavior).  
Quiz: â€œWhy must equals + hashCode be consistent?â€ Answer: Hash-based collections rely on it.

---

## Q6. Autoboxing / Unboxing
Definition: Automatic conversion between primitive and wrapper.

Performance Impact:
- Boxing creates objectsâ€”can hurt GC in loops.
- Null unboxing throws NullPointerException.

Code:
```java
long start = System.nanoTime();
Long sum = 0L;
for (long i = 0; i < 10_000_000L; i++) {
  sum += i; // sum is Long â†’ boxing each iteration
}
long end = System.nanoTime();
System.out.println("Time: " + (end - start));
```
Optimize:
```java
long sum2 = 0;
for (long i = 0; i < 10_000_000L; i++) sum2 += i;
```

Pitfall: Accidental use of wrapper in hot paths.  
Quiz: â€œWhat exception from `Integer n = null; int x = n;`?â€ (NullPointerException)

---

## Q7. Default Values of Instance Variables
Defaults (instance members):
- int: 0
- long: 0L
- boolean: false
- char: '\u0000'
- Object refs: null

Local variables: MUST be explicitly initialized.

Example:
```java
public class Defaults {
  int x; boolean flag; String name;
  void test(){
    int local;
    // System.out.println(local); // compile error
    System.out.println(x + " " + flag + " " + name);
  }
}
```

Pitfall: Assuming local variables get defaults.  
Quiz: â€œWhat prints for uninitialized char?â€ Looks blank (null character).

---

## Q8. Pass-by-Value or Reference?
Java is strictly pass-by-value. For object parameters, the value passed is the reference (pointer) copy.
But hereâ€™s the trick:

When you pass a primitive, the actual value is copied.

When you pass an object, the value of the reference (memory address) is copied â€” not the object itself.
So both variables point to the same object, but the reference itself is a copy.

Thatâ€™s why people sometimes get confused and think Java is pass-by-reference.

ğŸ“Œ Example 1: Primitives (Pass-by-Value)
public class PassByValue {
public static void changeValue(int x) {
x = 50;
}

    public static void main(String[] args) {
        int a = 10;
        changeValue(a);
        System.out.println(a); // 10 (not changed)
    }
}

Example:
```java
void mutate(StringBuilder sb){ sb.append("X"); }
void reassign(StringBuilder sb){ sb = new StringBuilder("New"); }

StringBuilder a = new StringBuilder("A");
mutate(a);       // a -> "AX"
reassign(a);     // a still "AX"
```

Pitfall: Saying â€œJava is pass-by-reference.â€  
Analogy: You photocopy an address; changes at the address are visible, but changing the paperâ€™s content (new address) wonâ€™t update original.  
Quiz: â€œCan a method replace callerâ€™s object?â€ (Not unless a wrapper container is mutated.)

---

## Q9. Primitive vs Wrapper Types
Comparison:
- Performance: primitives faster.
- Nullability: wrappers can be null.
- Collections: need wrappers.
- Identity semantics: wrappers cached for some values.

Example Cache Demo:
```java
Integer a = 127, b = 127;
Integer c = 128, d = 128;
System.out.println(a == b); // true
System.out.println(c == d); // false
```

Pitfall: Storing large numbers of boxed values in tight loops.  
Quiz: â€œWhy no primitives in generics?â€ (Type erasure design.)

---

## Q10. What is a Package?
Purpose: Namespace control, prevents naming conflicts, access control (package-private visibility).

Example:
```java
package com.example.util;
public class MathUtil {}
```

Access Modifier Impact:
- No modifier (default) means package-private.
- Use consistent domain-based naming (reverse domain carefully).

Pitfall: Cyclic package dependencies (architectural smell).  
Quiz: â€œCan two packages have same class name?â€ Yesâ€”fully qualified name disambiguates.

---

## Q11. Four Pillars of OOP
List: Encapsulation, Inheritance, Polymorphism, Abstraction.

Short Clarifications:
- Encapsulation: Hide data behind methods.
- Inheritance: Reuse via extends (use sparingly).
- Polymorphism: Runtime dispatch based on actual type.
- Abstraction: Focus on essential behavior (interfaces/abstract classes).

Example (Polymorphism):
```java
interface Notifier { void send(String msg); }
class EmailNotifier implements Notifier { public void send(String msg){ System.out.println("Email: " + msg); } }
class SmsNotifier implements Notifier { public void send(String msg){ System.out.println("SMS: " + msg); } }

Notifier n = new SmsNotifier();
n.send("Hi");
```

Pitfall: Overusing inheritance where composition fits.  
Quiz: â€œWhere does dynamic dispatch occur?â€ (At runtime via vtable.)

---

## Q12. Abstraction vs Encapsulation
Abstraction: Expose what something does (interfaces).  
Encapsulation: Hiding internal state & representation (private fields).

Example:
```java
interface Storage { void put(String key, String val); String get(String key); }
class InMemoryStorage implements Storage {
  private final Map<String,String> map = new HashMap<>();
  public void put(String k,String v){ map.put(k,v); }
  public String get(String k){ return map.get(k); }
}
```

Pitfall: Using public fields (breaks encapsulation).  
Quiz: â€œIs abstraction possible without encapsulation?â€ (Yes, but they complement each other.)

---

## Q13. Method Overloading vs Overriding
Overloading: Same name, different parameter list (compile-time resolution).  
Overriding: Same signature in subclass, runtime dispatch.

Example:
```java
class Calc {
  int add(int a,int b){ return a+b; }
  double add(double a,double b){ return a+b; } // overload
}
class AdvCalc extends Calc {
  @Override
  int add(int a,int b){ return a+b+1; } // override
}
```

Pitfall: Changing only return type is NOT overloading.  
Quiz: â€œIs overriding based on parameter types?â€ (Noâ€”signature must match.)

---

## Q14. Can Static Methods Be Overridden?
Answer: No. They are hidden (shadowed). Binding is compile-time.

Example:
```java
class A { static void hi(){ System.out.println("A"); } }
class B extends A { static void hi(){ System.out.println("B"); } }
A a = new B();
a.hi(); // prints A
```

Pitfall: Expecting polymorphic behavior for static methods.  
Quiz: â€œWhat prints?â€ (A)

---

## Q15. Can Constructors Be Overridden?
Answer: No. They are not inherited. They can be overloaded.

Example:
```java
class Person {
  Person(){ this("Unknown"); }
  Person(String name){ System.out.println(name); }
}
```

Pitfall: Thinking constructor names behave like methods.  
Quiz: â€œDoes subclass inherit parent constructors?â€ (No.)

---

## Q16. this vs super
this: Refers to current instance.  
super: Refers to immediate parent implementation / constructor.

Example:
```java
class Parent { Parent(){ System.out.println("Parent ctor"); } void greet(){ System.out.println("Parent greet"); } }
class Child extends Parent {
  Child(){ super(); System.out.println("Child ctor"); }
  void greet(){ super.greet(); System.out.println("Child greet"); }
}
```

Pitfall: Calling overridable methods inside constructors (can see partially constructed object).  
Quiz: â€œWhy avoid calling a non-final method in ctor?â€ (Subclass may see inconsistent state.)

---

## Q17. Order of Initialization
Order:
1. Static fields & static blocks (parent â†’ child).
2. Instance fields & instance initializer blocks (parent â†’ child).
3. Constructors (parent â†’ child).

Example:
```java
class A {
  static { System.out.println("A static"); }
  { System.out.println("A init"); }
  A(){ System.out.println("A ctor"); }
}

class B extends A {
  static { System.out.println("B static"); }
  { System.out.println("B init"); }
  B(){ System.out.println("B ctor"); }
}

public class Test {
  public static void main(String[] args) {
    new B();
  }
}
```
Output:
```
A static
B static
A init
A ctor
B init
B ctor
```

Pitfall: Relying on uninitialized fields during chain.  
Quiz: â€œWhen does child static block run?â€ (After parent static.)

---

## Q18. Composition vs Inheritance
Composition: â€œHas-aâ€, more flexible.  
Inheritance: â€œIs-aâ€, tight coupling.

Poor Inheritance Example:
```java
class Stack extends Vector {} // discouraged (exposes too much)
```

Good Composition:
```java
class Stack<E> {
  private final Deque<E> deque = new ArrayDeque<>();
  void push(E e){ deque.push(e); }
  E pop(){ return deque.pop(); }
}
```

Pitfall: Subclassing for code reuse leads to fragile base class problems.  
Interview Tip: Cite â€œEffective Javaâ€ (Item: Favor composition over inheritance).  
Quiz: â€œWhich is preferable for adding logging to a service?â€ (Composition via decorator.)

---

## Q19. Uses of final
- final variable: reference cannot be reassigned.
- final field + proper construction = safe publication for immutable objects.
- final method: cannot be overridden.
- final class: cannot be subclassed (e.g., String).

Example:
```java
final class Token {}
```

Pitfall: final reference â‰  immutable object (internal state may mutate).  
Quiz: â€œDoes final guarantee thread-safe object?â€ (Noâ€”only forbids reassignment.)

---

## Q20. Designing an Immutable Class
Rules:
- Declare class final (optional but recommended).
- All fields private & final.
- No setters.
- Defensive copies for mutable inputs & outputs.
- Ensure â€˜thisâ€™ not leaked during construction.

Example (with defensive copy):
```java
public final class UserProfile {
  private final String username;
  private final List<String> roles;

  public UserProfile(String username, List<String> roles) {
    this.username = username;
    this.roles = List.copyOf(roles); // defensive copy (Java 10+)
  }

  public String username(){ return username; }
  public List<String> roles(){ return roles; } // safe (unmodifiable)
}
```

Mutable Leak Example (Wrong):
```java
public List<String> roles(){ return roles; } // if roles were mutable
```

Pitfall: Exposing internal Date, List, arrays.  
Quiz: â€œWhy copy mutable collections?â€ (Prevent external modification.)

---

## MINI RECAP BLOCK (Optional On-Screen Slide)
Covered:
1â€“3: Platform & execution
4â€“6: Method & equality basics
7â€“10: Initialization & packaging
11â€“15: OOP pillars & dispatch
16â€“20: Construction order, design patterns, immutability

---

## SAMPLE SHORTS EXTRACT TEMPLATE
(For Q5 example)
Hook: â€œWhy does â€˜==â€™ sometimes fail in Java strings?â€  
Explain: â€œBecause â€˜==â€™ checks references. Use equals() for contentâ€¦â€  
Show Code â†’ Provide wrapper cache twist.

---

## PRACTICE QUIZ (End of Episode)
1. Why are wrapper == comparisons unreliable sometimes?
2. What happens if you override equals but not hashCode?
3. Can static blocks access instance fields?
4. What problem does defensive copying solve?
5. Is Java pass-by-reference ever? (Answer all at end or next video.)

Answer Slide:
1. Wrapper caching & different objects.
2. Breaks HashMap contract â†’ lost lookups.
3. Noâ€”static context only has static members.
4. Prevents external mutation of internal state.
5. Noâ€”always pass-by-value (reference value copied).

---

## RECOMMENDED VIDEO SPLIT
Part 1 (Q1â€“Q10): â€œFoundations & Execution Modelâ€  
Part 2 (Q11â€“Q20): â€œObject Model & Immutability Masteryâ€

---

## CALL TO ACTION (End)
â€œIf this helped, star the notes repo, and drop â€˜Part 2â€™ in the comments. Next: Garbage Collection or Collectionsâ€”your choice.â€

---

## RAW OUTLINE (For Teleprompter)
- Hook
- JDK/JRE/JVM deep analogy
- Bytecode & JVM optimization
- main() signature nuance
- Equality (== vs equals)
- Boxing performance caution
- Initialization rules
- OOP pillars clarified
- Overloading vs overriding traps
- Immutability design fundamentals
- Recap + Quiz + CTA

---

Let me know if you want:
- Slide deck skeleton (PowerPoint / Google Slides outline)
- A printable PDF condensed cheat sheet
- Flashcards for spaced repetition (Q1â€“Q20)
- A script variation in conversational tone

Just ask: â€œGenerate slides for Q1â€“Q10â€ or â€œCreate flashcards for Section 1.â€
